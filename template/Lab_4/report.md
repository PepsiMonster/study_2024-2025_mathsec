---
title: Документ
---

# Цель работы

Цель данной лабораторной работы — изучить различные алгоритмы для вычисления наибольшего общего делителя (НОД) двух целых чисел, а также освоить их программную реализацию на языке 
Julia
. В рамках лабораторной работы необходимо реализовать алгоритм Евклида, бинарный алгоритм Евклида, расширенный алгоритм Евклида, а также расширенный бинарный алгоритм Евклида.

# Задание

1. **Реализовать алгоритм Евклида для нахождения наибольшего общего делителя.**
2. **Реализовать бинарный алгоритм Евклида.**
3. **Реализовать расширенный алгоритм Евклида.**
4. **Реализовать расширенный бинарный алгоритм Евклида.**

# Теоретическое введение

### Определение наибольшего общего делителя

Наибольший общий делитель (НОД) двух или более целых чисел — это наибольшее целое число \( d \), которое делит эти числа без остатка. Если числа \( a_1, a_2, ..., a_k \) имеют НОД равный \( d \), то выполняются следующие условия:
1. Каждое из чисел \( a_1, a_2, ..., a_k \) делится на \( d \).
2. \( d \) является наибольшим числом, которое удовлетворяет первому условию.

$$
\text{Если НОД}(a, b) = 1 \Rightarrow \text{ числа } a \text{ и } b \text{ взаимно просты}
$$

### Алгоритм Евклида

Алгоритм Евклида используется для нахождения наибольшего общего делителя (НОД) двух целых чисел 
$$
( a ) \text{ и } ( b ), \text{ где } ( 0 < b \leq a )
$$

#### Пошаговый алгоритм Евклида

1. **Инициализация**:
   - Задаем начальные значения: 
$$
( r_0 \leftarrow a ), ( r_1 \leftarrow b ), ( i \leftarrow 1 ).
$$

1. **Деление с остатком**:
   - Находим остаток от деления:
$$
 r_{i-1}  \text{ на }  r_i . \text{Обозначим этот остаток как }  r_{i+1} .
$$

3. **Проверка на завершение**:
$$
\text{Если } r_{i+1} = 0, \text{ то устанавливаем } d \gets r_i, \text{ где } d \text{ — это НОД двух чисел } a \text{ и } b.
$$
$$
\text{Если } r_{i+1} \neq 0, \text{ то увеличиваем } i \text{ на 1 и повторяем шаг 2.}
$$


4. **Результат**:
$$
\text{После завершения алгоритма } ( d ) \text{содержит НОД чисел} ( a ) \text{и} ( b ).
$$


### Бинарный алгоритм Евклида (поиск наибольшего общего делителя)

Бинарный алгоритм Евклида — это улучшенная версия классического алгоритма Евклида, которая быстрее выполняется на компьютерах благодаря использованию операций сдвига для работы с двоичными представлениями чисел.

#### Пошаговое описание алгоритма

1. **Инициализация множителя**:
$$
\text{Задаем} ( g \leftarrow 1 ). \text{Этот множитель} ( g ) \text{будет использоваться для хранения общего множителя 2, если оба числа  a и  b  четные}
$$
2. **Удаление общих множителей 2 из \( a \) и \( b \)**:
   - Пока оба числа \( a \) и \( b \) четные, делим их на 2 и умножаем \( g \) на 2:
     $$
     a \leftarrow \frac{a}{2}, \quad b \leftarrow \frac{b}{2}, \quad g \leftarrow 2g
     $$
   - Этот шаг выполняется до тех пор, пока одно из чисел не станет нечетным.

3. **Инициализация переменных для основного цикла**:
$$
\text{Устанавливаем }  u \leftarrow a  \text{ и }  v \leftarrow b .
$$
4. **Основной цикл**:
   - Пока 
$$ 
u \neq 0 \text{, выполняем следующие действия:}.
$$
- **Шаг 4.1**: 
$$
\text{Если  u  четное, то делим его на 2: } u\leftarrow \frac{u}{2}
$$
- **Шаг 4.2**: 
$$
\text{Если \( v \) четное, то делим его на 2: } v\leftarrow \frac{v}{2}
$$
- **Шаг 4.3**: 
$$
\text{Если } u \geq v , \text{то заменяем  u  на u - v ; в противном случае заменяем  v  на  v - u}.
$$

1. **Вычисление НОД**:
$$
\text{Когда  u = 0 , устанавливаем }  d \leftarrow g \times v . \text{Это и будет НОД чисел  a и b}.
$$
1. **Результат**:
   - Итоговое значение  d  является наибольшим общим делителем чисел  a и b.

Бинарный алгоритм Евклида эффективен для выполнения на компьютере, поскольку использует операции деления и вычитания, которые хорошо работают с двоичными числами, минимизируя количество арифметических операций.

**Пример выполнения:**
Пусть даны числа \( a = 12345 \) и \( b = 24690 \). В ходе выполнения алгоритма Евклида последовательно находим остатки от деления, пока одно из чисел не станет нулём.

### Расширенный алгоритм Евклида

Расширенный алгоритм Евклида позволяет не только найти НОД двух чисел, но и найти такие целые числа \( x \) и \( y \), что \( ax + by = НОД(a, b) \). Это уравнение называется линейной комбинацией. Расширенный алгоритм полезен для задач, где требуется найти коэффициенты линейной комбинации, например, в криптографии.

### Расширенный бинарный алгоритм Евклида

### Расширенный алгоритм Евклида (поиск НОД и коэффициентов линейного представления)

Расширенный алгоритм Евклида не только находит наибольший общий делитель (НОД) чисел \( a \) и \( b \), но и определяет целые числа \( x \) и \( y \) такие, что выполняется равенство:
$$
ax + by = d \text{ где } ( d = \text{НОД}(a, b) ).
$$

#### Пошаговое описание алгоритма

1. **Инициализация**:
   - Задаем начальные значения:
     $$
     r_0 \leftarrow a, \quad r_1 \leftarrow b, \quad x_0 \leftarrow 1, \quad x_1 \leftarrow 0, \quad y_0 \leftarrow 0, \quad y_1 \leftarrow 1, \quad i \leftarrow 1
     $$

2. **Деление с остатком**:
   - Разделяем: 
    $$ 
    r_{i-1}  \text{ на }  r_i  \text{ с остатком, получая: }
    r_{i-1} = q_i \cdot r_i + r_{i+1}
    \text{ где }  q_i  \text{ — это частное, а }  r_{i+1}  \text{ — остаток.}
    $$
1. **Проверка на завершение**:
$$
\text{- Если } r_{i+1} = 0, \text{ то устанавливаем:} \\
d \leftarrow r_i, \quad x \leftarrow x_i, \quad y \leftarrow y_i \\

\text{- Если } r_{i+1} \neq 0, \text{ то обновляем значения коэффициентов:} \\
x_{i+1} \leftarrow x_{i-1} - q_i \cdot x_i, \quad y_{i+1} \leftarrow y_{i-1} - q_i \cdot y_i
$$
- Затем увеличиваем \( i \) на 1 и возвращаемся к шагу 2.

2. **Результат**:
   - После завершения алгоритма \( d \), \( x \), и \( y \) будут такими, что:
     $$
     ax + by = d
     $$

### Расширенный бинарный алгоритм Евклида

Расширенный бинарный алгоритм Евклида позволяет не только находить наибольший общий делитель (НОД) двух чисел \( a \) и \( b \), но также определяет коэффициенты \( x \) и \( y \) для линейного представления:
$$
ax + by = d
$$
где 
$$
d = \text{НОД}(a, b) 
$$

#### Пошаговое описание алгоритма

1. **Инициализация множителя**:
   - Устанавливаем \( g ⟵  1 \). Этот множитель будет использоваться для учета общего множителя 2, если оба числа \( a \) и \( b \) четные.

2. **Удаление общих множителей 2 из \( a \) и \( b \)**:
   - Пока оба числа \( a \) и \( b \) четные, делим их на 2 и удваиваем \( g \):
     $$
     a \leftarrow \frac{a}{2}, \quad b \leftarrow \frac{b}{2}, \quad g \leftarrow 2g
     $$
   - Этот процесс продолжается до тех пор, пока одно из чисел не станет нечетным.

3. **Инициализация переменных для расширенного алгоритма**:
   - Задаем начальные значения:
     $$
     u \leftarrow a, \quad v \leftarrow b, \quad A \leftarrow 1, \quad B \leftarrow 0, \quad C \leftarrow 0, \quad D \leftarrow 1
     $$

4. **Основной цикл**:
    $$
    \begin{align*}
    &\text{- Пока } u \neq v, \text{ выполняем следующие действия:} \\
    &\quad \text{- Шаг 4.1: Если } u \text{ четное, то:} \\
    &\quad\quad \text{4.1.1 Если } u \text{ четное, делим его на 2:} \\
    &\quad\quad u \leftarrow \frac{u}{2} \\
    &\quad\quad \text{4.1.2 Если оба числа } A \text{ и } B \text{ четные, делим их на 2:} \\
    &\quad\quad A \leftarrow \frac{A}{2}, \quad B \leftarrow \frac{B}{2} \\
    &\quad\quad \text{В противном случае:} \\
    &\quad\quad A \leftarrow \frac{A + b}{2}, \quad B \leftarrow \frac{B - a}{2}
    \end{aligned}
    $$

    $$
    \begin{aligned}
    &\text{- Шаг 4.2: Если } v \text{ четное, то:} \\
    &\quad \text{4.2.1 Если } v \text{ четное, делим его на 2:} \\
    &\quad v \leftarrow \frac{v}{2} \\
    &\quad \text{4.2.2 Если оба числа } C \text{ и } D \text{ четные, делим их на 2:} \\
    &\quad C \leftarrow \frac{C}{2}, \quad D \leftarrow \frac{D}{2} \\
    &\quad \text{В противном случае:} \\
    &\quad C \leftarrow \frac{C + b}{2}, \quad D \leftarrow \frac{D - a}{2} \\

    &\text{- Шаг 4.3: Если } u \geq v, \text{ то:} \\
    &\quad u \leftarrow u - v, \quad A \leftarrow A - C, \quad B \leftarrow B - D \\
    &\text{В противном случае:} \\
    &\quad v \leftarrow v - u, \quad C \leftarrow C - A, \quad D \leftarrow D - B
    \end{aligned}
    $$


5. **Вывод результата**:
   - После завершения цикла устанавливаем:
     $$
     d \leftarrow g \times v, \quad x \leftarrow C, \quad y \leftarrow D
     $$

6. **Результат**:
   - Итоговое значение \( d \), \( x \), и \( y \) такое, что:
     $$
     ax + by = d
     $$

# Выполнение лабораторной работы

### Реализация алгоритма Евклида

Алгоритм Евклида начинается с инициализации чисел \( r_0 = a \) и \( r_1 = b \). Затем производится деление с нахождением остатка, пока остаток не станет равным нулю. На каждом шаге:
- Делим большее число на меньшее.
- Запоминаем остаток.
- Если остаток равен нулю, то текущее меньшее число является НОД.

**Пример кода:** 
```julia
a = 4567890
b = 462

function euclidian_algorithm(a,b)
    if a<b
        a,b=b,a
    end
    r_0 = a
    r_1 = b 
    while true
        r_next= r_0 % r_1
        if r_next == 0
            return r_1
        end
        r_0 = r_1
        r_1 = r_next
    end
end

println(euclidian_algorithm(a,b))
```

    6

### Реализация бинарного алгоритма Евклида

Бинарный алгоритм Евклида проверяет чётность обоих чисел. На каждом шаге:
1. Если оба числа чётные, делим их пополам и умножаем результат на 2.
2. Если одно из чисел чётное, делим только его.
3. Если оба нечётные, из большего вычитаем меньшее, делим результат на 2 и повторяем.

**Пример кода:** 
```julia
a = 678908890
b = 2937

function euclidian_binary(a,b)
    if a<b
        a,b=b,a
    end
    g = 1
    while a%2==0 && b%2==0
        a = div(a,2)
        b = div(a,2)
        g*= 2
    end
    u = a 
    v = b
    while u!=0
        while u%2==0
            u = div(u,2)
        end
        while v%2==0
            v = div(v,2)
        end
        if u>=v
            u -= v 
        else
            v -= u
        end 
    end
    d = g*v
    return d
end

println(euclidian_binary(a,b))
```

    11

### Реализация расширенного алгоритма Евклида

В расширенном алгоритме Евклида на каждом шаге вычисления остатка также обновляются коэффициенты \( x \) и \( y \) для линейной комбинации. Процесс продолжается до тех пор, пока один из остатков не станет нулём. На этом этапе значения \( x \) и \( y \) дают линейное представление НОД.

**Пример кода:** 
```julia
a = 3984759347
b = 47584

function euclidian_ext(a,b)
    if a<b
        a,b=b,a
    end
    r_0 = a
    r_1 = b
    x_0=1 # a*x + b*y = d (НОД(a,b))
    x_1=0 
    y_0=0
    y_1=1
    while r_1!=0
        q = div(r_0,r_1)
        r_next = r_0 - q*r_1 # НОД(r_0,r_1)
        r_0 = r_1
        r_1 = r_next

        x_next = x_0 - q*x_1
        x_0 = x_1
        x_1 = x_next

        y_next = y_0-q*y_1
        y_0 = y_1
        y_1 = y_next
    end 
    d = r_0
    x = x_0
    y = y_0
    return d, x, y
end
println(euclidian_ext(a,b))
```

    (1, 18011, -1508269599)
    

**Проверка**
```julia
d, x, y = euclidian_ext(a,b)
check = a*x+b*y
println(check)


    1
```

### Реализация расширенного бинарного алгоритма Евклида

В расширенном бинарном алгоритме Евклида используется тот же процесс, что и в бинарном алгоритме, но также включены вычисления для коэффициентов линейной комбинации. Алгоритм проходит следующие шаги:
1. Инициализируем коэффициенты и выполняем деление пополам, если числа чётные.
2. На каждом шаге вычисления коэффициентов учитываются изменения в значениях чисел.
3. Процесс продолжается до тех пор, пока одно из чисел не станет равным нулю.

**Пример кода:** 

```julia
a = 1024
b = 512

function euclidean_ext_bin(a, b)
    if a < b
        a, b = b, a
    end
    g = 1
    while a % 2 == 0 && b % 2 == 0
        a = div(a, 2)
        b = div(b, 2)
        g *= 2
    end
    u = a
    v = b
    A = 1
    B = 0
    C = 0
    D = 1
    while u != 0
        while u % 2 == 0
            u = div(u, 2)
            if A % 2 == 0 && B % 2 == 0
                A = div(A, 2)
                B = div(B, 2)
            else
                A = div(A + b, 2)
                B = div(B - a, 2)
            end
        end
        while v % 2 == 0
            v = div(v, 2)
            if C % 2 == 0 && D % 2 == 0
                C = div(C, 2)
                D = div(D, 2)
            else
                C = div(C + b, 2)
                D = div(D - a, 2)
            end
        end
        if u >= v
            u -= v
            A -= C
            B -= D
        else
            v -= u
            C -= A
            D -= B
        end
    end
    d = g * v
    x = C
    y = D
    return d, x, y
end
println(euclidean_ext_bin(a,b))


    (512, 0, 1)
```    

**Проверка**
```julia
d, x, y = euclidean_ext_bin(a,b)
check = a*x+b*y 
println(check)
```

    512

# Выводы

В ходе выполнения лабораторной работы были изучены и реализованы 4 вариации *Алгоритма Евклида* для нахождения НОД, включая их расширенные версии. Каждый из алгоритмов имеет свои преимущества и применяется в зависимости от требований к вычислительной эффективности или необходимости в нахождении коэффициентов линейной комбинации. Бинарный алгоритм показал себя как более быстрый для реализации на компьютере, в то время как расширенные алгоритмы обеспечили возможность нахождения дополнительных параметров.

# Список литературы

::: {#[Лабораторная_работа_4](https://esystem.rudn.ru/mod/folder/view.php?id=1150970)}
:::